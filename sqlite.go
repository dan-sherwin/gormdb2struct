package main

import (
	"bytes"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"github.com/dan-sherwin/gormdb2struct/sqlitetype"
	"github.com/glebarez/sqlite"
	"github.com/iancoleman/strcase"
	"gorm.io/gen"
	"gorm.io/gorm"
)

func sqliteToGorm(cfg ConversionConfig) {
	var db *gorm.DB
	var err error
	db, err = gorm.Open(sqlite.Open(cfg.Sqlitedbpath), &gorm.Config{})
	if err != nil {
		log.Fatal(err.Error())
	}
	sqldb, _ := db.DB()
	err = sqldb.Ping()
	if err != nil {
		log.Fatal("Unable to ping database: " + err.Error())
	}
	if cfg.CleanUp {
		cleanUp(cfg.OutPath)
	}
	g := gen.NewGenerator(gen.Config{
		OutPath:           cfg.OutPath,
		ModelPkgPath:      cfg.OutPath + "/models",
		WithUnitTest:      false,
		FieldNullable:     true,
		FieldCoverable:    true,
		FieldSignable:     true,
		FieldWithIndexTag: true,
		FieldWithTypeTag:  true,
		Mode:              gen.WithoutContext | gen.WithDefaultQuery | gen.WithQueryInterface, // generate mode
	})

	// JSON tag strategy same as Postgres generator
	g.WithJSONTagNameStrategy(func(col string) (tag string) { return strcase.ToLowerCamel(col) })
	// Use SQLite-specific type map (no Postgres materialized views handling)
	dtMaps := sqlitetype.TypeMap
	for k, v := range cfg.TypeMap {
		dtMaps[k] = func(columnType gorm.ColumnType) string { return v }
	}
	g.WithDataTypeMap(dtMaps)
	g.WithImportPkgPath("gorm.io/datatypes")
	g.UseDB(db)

	// Build models to allow extraFields and jsonTagOverrides like Postgres path
	modelsMap := map[string]any{}
	modelStructNames := []string{}
	tables := []string{}
	if cfg.Tables != nil {
		tables = *cfg.Tables
	} else {
		tables = sqlitetype.TableNames(db)
	}

	for _, tableName := range tables {
		model := g.GenerateModel(tableName)
		if ef, ok := cfg.ExtraFields[tableName]; ok {
			for _, ef := range ef {
				a := gen.FieldNew("", "", nil)
				f := a(nil)
				genRelationField(&ef, gen.Field(f))
				model.Fields = append(model.Fields, f)
			}
		}
		if jsonTagOverrides, ok := cfg.JsonTagOverridesByTable[tableName]; ok {
			for _, f := range model.Fields {
				if jsonTag, ok := jsonTagOverrides[f.ColumnName]; ok {
					f.Tag.Set("json", jsonTag)
				} else if jsonTag, ok := jsonTagOverrides[f.Name]; ok {
					f.Tag.Set("json", jsonTag)
				}
			}
		}
		modelsMap[tableName] = model
		modelStructNames = append(modelStructNames, model.ModelStructName)
	}

	models := []any{}
	for _, m := range modelsMap {
		models = append(models, m)
	}
	g.ApplyBasic(models...)
	g.Execute()
	if cfg.GenerateDbInit {
		generateSqliteDbInit(cfg, g)
	}
}

func generateSqliteDbInit(cfg ConversionConfig, g *gen.Generator) {
	outPath := g.OutPath
	fullPackageName := filepath.Base(outPath)
	if cfg.OutPackagePath != "" {
		fullPackageName = cfg.OutPackagePath
	}
	packageName := filepath.Base(fullPackageName)
	modelStructNames := []string{}
	for modelName := range g.Data {
		modelStructNames = append(modelStructNames, modelName)
	}

	data := struct {
		PackageName        string
		FullPackageName    string
		DbPath             string
		IncludeAutoMigrate bool
		ModelStructNames   []string
	}{
		PackageName:        packageName,
		FullPackageName:    fullPackageName,
		DbPath:             "dev/db-query-model-generator/schema.db",
		IncludeAutoMigrate: cfg.IncludeAutoMigrate,
		ModelStructNames:   modelStructNames,
	}

	tmpl, err := template.New("sqliteDbInit").Parse(sqliteDbInitTemplate)
	if err != nil {
		log.Fatal(err)
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatal(err)
	}

	outFile := filepath.Join(outPath, "db_sqlite.go")
	if err := os.WriteFile(outFile, buf.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
}

var sqliteDbInitTemplate = `
// Code generated by gormdb2struct; DO NOT EDIT.
// This file was generated automatically to initialize SQLite DB connections.
// Warning: Manual edits may be overwritten by the generator and IDEs like GoLand may mark this as generated code.
package {{.PackageName}}

import (
	"log/slog"
	"os"
	slogGorm "github.com/orandin/slog-gorm"
	"github.com/glebarez/sqlite"
	"gorm.io/gorm"
	"{{.FullPackageName}}/models"
)

var (
	DbPath = "{{.DbPath}}"
	DB *gorm.DB
)

// DbInit opens the SQLite database. If optionalFilePath is provided, it will be used instead of the default DbPath.
func DbInit(optionalFilePath ...string) {
	var filePath string
	if len(optionalFilePath) > 0 && optionalFilePath[0] != "" {
		filePath = optionalFilePath[0]
	} else {
		filePath = DbPath
	}
	slog.Info("Connecting to sqlite database", slog.String("path", filePath))
	gormDB, err := gorm.Open(sqlite.Open(filePath), &gorm.Config{Logger: slogGorm.New()})
	if err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
	sqldb, _ := gormDB.DB()
	if err = sqldb.Ping(); err != nil {
		slog.Error("Unable to ping database: ", slog.String("error", err.Error()))
		os.Exit(1)
	}
	slog.Info("SQLite database connection established")

	{{if .IncludeAutoMigrate}}
	// Ensure schema exists using AutoMigrate.
	slog.Debug("Ensuring database schema via AutoMigrate (SQLite)")
	if err = gormDB.AutoMigrate(
		{{- range .ModelStructNames}}
		&models.{{.}}{},
		{{- end}}
	); err != nil {
		slog.Error("Unable to ensure database schema", slog.String("error", err.Error()))
		os.Exit(1)
	}
	{{end}}

	// Expose the query objects for use elsewhere in the app.
	SetDefault(gormDB)
	DB = gormDB
	slog.Debug("GORM query objects (SQLite) initialized")
}
`
